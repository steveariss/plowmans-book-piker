# Book Picker

A single-page web app that lets students (ages 4-6) browse picture book covers and select 2 books they like. Teachers set up each student, curate the book list, and view a report of selections. All Chromebooks share the same data via a central server.

## Specs

- **High-level spec**: `_specs/book-picker-high-level-spec.md` — product requirements, user flows, and UI/UX details.
- **Technical spec**: `_specs/technical-spec.md` — tech stack, architecture, API contract, database schema, component tree, implementation phases, and design decisions.

**Read both spec files before making any implementation decisions.**

## Tech Stack

| Layer          | Technology                                        |
| -------------- | ------------------------------------------------- |
| Frontend       | React 19 + Vite                                   |
| Routing        | React Router v7                                   |
| Styling        | CSS Modules + CSS custom properties               |
| Virtual Scroll | @tanstack/react-virtual (admin grid only)         |
| Carousel       | Swiper or embla-carousel-react                    |
| Animations     | CSS animations + canvas-confetti                  |
| Backend        | Node.js + Express                                 |
| Database       | SQLite via better-sqlite3                         |
| Scraper        | Playwright (target site is a client-rendered SPA) |
| Node Version   | 20 LTS minimum                                    |

## Project Structure

```text
book-picker/
├── _specs/          # Specification documents (not deployed)
├── scraper/         # Playwright-based scraper (standalone)
├── server/          # Express API + static file serving
├── client/          # React SPA (Vite)
├── data/            # Scraped book data + images (gitignored)
└── CLAUDE.md
```

Each of `scraper/`, `server/`, and `client/` has its own `package.json`. The root `package.json` has convenience scripts to orchestrate them.

## Key Commands

```bash
npm run dev          # Start both Vite dev server + Express server (concurrently)
npm run dev:server   # Express only (with --watch)
npm run dev:client   # Vite only (port 5173)
npm run build        # Production build of React app → client/dist/
npm start            # Start Express server (serves built client + API)
npm run scrape       # Run the full scraper pipeline
npm run lint         # ESLint
npm run format       # Prettier
```

## Architecture Overview

### Data Flow

1. **Scraper** → produces `data/books.json` + `data/images/{bookId}/*.jpg`
2. **Server** → loads `books.json` into memory at startup; serves images as static files; provides REST API for selections and curation state
3. **Client** → React SPA consuming the API; served by Express in production, proxied via Vite in dev

### Database

SQLite stores only dynamic state:

- `deleted_books` table — IDs of books the teacher has hidden
- `selections` table — student name + 2 book picks per submission

Book data itself lives in `data/books.json` (static, generated by scraper). During development before the scraper runs, use `data/books-sample.json` (mock data with ~20 placeholder books).

### API Endpoints

```text
GET    /api/books           → Non-deleted books (student browsing)
GET    /api/books/all       → All books with deletion status (admin)
POST   /api/books/delete    → Hide books { bookIds: [] }
POST   /api/books/restore   → Restore books { bookIds: [] }
POST   /api/selections      → Save student picks { studentName, books: [{id, title}] }
GET    /api/selections      → All selections (report)
GET    /api/selections/csv  → Download as CSV
DELETE /api/selections      → Clear all selections
```

Full API contract with request/response shapes is in `_specs/technical-spec.md` §4.

### Frontend Routes

```text
/              → Teacher Setup (name entry + nav)
/browse        → Book Browsing Grid (student-facing)
/thanks        → Thank You / Confirmation
/admin/books   → Manage Books (teacher curation)
/admin/report  → Report (selections table + CSV)
```

## Implementation Phases

Follow these phases in order. Each phase should be completed and working before moving to the next:

1. **Project Scaffolding** — Initialize all package.json files, Vite, Express, SQLite schema, ESLint/Prettier, .gitignore, base CSS, and generate mock seed data (`data/books-sample.json` + placeholder images)
2. **Backend API** — All REST endpoints, DB init, error handling, static file serving. Use mock data for development.
3. **Frontend Core** — Router, TeacherSetup, BookBrowsing grid, hooks, PickButton, SelectionCounter, DoneButton, ThankYou
4. **Frontend Carousel** — Book preview modal using `<dialog>`, swipeable image carousel, PickButton inside carousel
5. **Frontend Admin** — ManageBooks (virtualized grid, search, select all, delete/restore), Report (table, CSV download, clear data)
6. **Scraper** — API discovery via Playwright, book list pagination, detail page scraping, image download with resumability. Run scraper and replace mock data with real data.
7. **Polish & Deploy** — Font loading, responsive testing at 1366×768, touch targets ≥ 48px, performance testing, deployment. **Deployment target: ask the user** before choosing a platform.

## Git Workflow

- **Commit after every implementation phase** and after completing any meaningful unit of work within a phase.
- Use clear, descriptive commit messages summarizing the "why" (e.g., "Add Express server with book and selection API endpoints").
- Initialize the git repo and make the first commit during Phase 1 (scaffolding).
- Do not batch large amounts of work into a single commit — prefer smaller, focused commits.

## Coding Conventions

- **ES Modules** throughout (`.mjs` extension for server/scraper, standard `.jsx` for client)
- **Functional React components** with hooks — no class components
- **CSS Modules** for component styles (e.g., `BookCard.module.css` alongside `BookCard.jsx`)
- **CSS custom properties** for design tokens defined in `client/src/styles/global.css`
- **`<dialog>` element** for modals (native focus trapping, backdrop, Escape key)
- **Native `loading="lazy"`** on `<img>` tags — no JS lazy-loading library needed
- **Validation at API boundary** only — trust internal code
- Keep components focused and flat — avoid deep nesting or premature abstraction
- No TypeScript — plain JavaScript with JSX

## Design Notes

- **Audience**: Children ages 4-6. Everything must be large, visual, tappable, and use minimal text.
- **Touch targets**: Minimum 48px. Primary action buttons (Pick, Done) are 72px tall.
- **Font**: Nunito (Google Fonts) — rounded, friendly.
- **Color palette**: Warm cream background (`#FFF8E1`), green for positive actions, blue for navigation, red for destructive (admin only).
- **Animations**: Bounce on selection, shake when at limit, slide-up for Done button, confetti on thank-you.

## Scraper Notes

- Target: `https://anotherstoryedu.ca/browse/filter/a/a4to6`
- The site is a **BookManager React SPA** (shop ID: `7603827`). The HTML is an empty `<div id="root">` — all content is JS-rendered.
- Images come from CDN: `cdn1.bookmanager.com`
- The scraper must use **Playwright** to render pages or intercept API calls.
- ~5,174 books to scrape. Full run takes significant time. Must be resumable.
- Rate limit: 1-2s delay between page requests, 100ms for CDN image downloads.
- Output: `data/books.json` + `data/images/{bookId}/cover.jpg` + `data/images/{bookId}/page-N.jpg`
